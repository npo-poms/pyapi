import abc
import argparse
import logging
import sys
import os
import copy


class NpoApiBase:
    __metaclass__ = abc.ABCMeta
    EPILOG = """
    DEBUG=true and ENV=<dev|test|prod> environment variables are recognized.
    Credentials are read from a config file. If such a file does not exist it will offer to create one.
    """

    def __init__(self, env: str = None, debug: bool = False, accept: str = None):
        """

        """
        logging.basicConfig(format='%(levelname)s %(message)s')
        self.logger = logging.getLogger("Npo")
        self.env(env)
        self.debug(debug)
        self.accept(accept)

    @abc.abstractmethod
    def env(self, e):
        """"Sets environment"""
        self._env = e
        return self

    def debug(self, arg=True):
        self.logger.setLevel(level=logging.DEBUG if arg else logging.ERROR)
        return self

    def accept(self, arg=None):
        if arg:
            self._accept = arg
        else:
            self._accept = "application/json"
        return self

    def read_environmental_variables(self):

        if self._env == None:
            if 'ENV' in os.environ:
                self.env(os.environ['ENV'])
            else:
                self.env('test')

        if 'DEBUG' in os.environ and os.environ['DEBUG'] == 'true':
            self.debug()

        return self

    def configured_login(self, read_environment=False, create_config_file=False):
        """
        Logs in using configuration file. Considered using json (no comments-> unusable) or configparser (nearly properties, but heading are required..)
        So, now it simply parses the file itself.
        :param create_config_file: If there is no existing config file, offer to create one
        :param read_environment: If this is set to true, shel environment variables like DEBUG and ENV will be recognized
        """
        if read_environment:
            self.read_environmental_variables()

        config_files = [
            os.path.join(os.path.expanduser("~"), "conf", "creds.properties"),
            os.path.join(os.path.dirname(__file__), "..", "..", "..", "creds.properties"),
            os.path.join(os.path.dirname(__file__), "..", "..", "..", "creds.sh"),
            os.path.join(os.path.dirname(__file__), "creds.properties")]

        config_file = None
        for file in config_files:
            if os.path.isfile(file):
                config_file = os.path.normpath(file)
                break
            else:
                self.logger.debug("not a file " + file)

        settings = {}
        if config_file:
            self.logger.debug("Reading " + config_file + " for env " + self._env)
            with open(config_file, "r") as f:
                for line in f:
                    l = line.strip()
                    if l and not l.startswith("#"):
                        key, value = l.split("=", 2)
                        split = key.split('.', 2)
                        if len(split) == 2:
                            e, key = split
                        else:
                            e = None
                        self.logger.debug("%s %s %s", e, key, value)
                        if not e or e == self._env:
                            settings[key.strip().lower()] = value.strip('" \t')

        if not config_file and create_config_file:
            print("No configuration file found. Now creating.")
            self.force_create_config = True

        if self.force_create_config:
            self.create_config(settings)
            config_file = None
            for file in config_files:
                config_file = os.path.normpath(file)
                if os.access(os.path.dirname(config_file), os.W_OK):
                    self.logger.debug("Found " + config_file)
                    break
                else:
                    self.logger.debug("Not writeable " +  config_file)
                    config_file = None

            if config_file:
                with open(config_file, "w") as f:
                    f.write("# Automaticly generated by " + __file__ + "\n")
                    for key in settings:
                        f.write(key + "=" + settings[key] + "\n")
                        f.write(self._env + "." + key + "=" + settings[key] + "\n")
            else:
                print("(Configuration could not be saved since no file of %s is writable" % str(config_files))

        if self.logger.isEnabledFor(logging.DEBUG):
            settings_for_log = copy.copy(settings)
            self.anonymize_for_logging(settings_for_log)
            self.logger.debug("settings" + str(settings_for_log))

        self.logger.debug("Reading settings")
        self.read_settings(settings)

        return self

    @abc.abstractmethod
    def anonymize_for_logging(self, settings):
        return

    @abc.abstractmethod
    def create_config(self, settings):
        """

        """

        return self

    @abc.abstractmethod
    def read_settings(self, settings):
        """
        """
        return

    def command_line_client(self, description=None, read_environment=True, create_config_file=True):
        self.common_arguments(description=description)
        return self.configured_login(read_environment=read_environment, create_config_file=create_config_file)

    def add_argument(self, *args, **kwargs):
        self.argument_parser.add_argument(*args, **kwargs)

    def common_arguments(self, description=None):
        parent_args = argparse.ArgumentParser(add_help=False)
        parent_args.add_argument('-a', "--accept", type=str, default=None, choices={"json", "xml"})
        parent_args.add_argument('-e', "--env", type=str, default=None, choices={"test", "prod", "dev"})
        parent_args.add_argument('-c', "--createconfig", action='store_true', help="Create config")
        parent_args.add_argument('-d', "--debug", action='store_true', help="Switch on debug logging")
        pargs = parent_args.parse_args(filter(lambda e: e in ["-d", "--debug", "-c", "--createconfig"], sys.argv))
        self.debug(pargs.debug)
        self.force_create_config = pargs.createconfig
        self.argument_parser = argparse.ArgumentParser(description=description,
                                                       parents=[parent_args],
                                                       epilog=NpoApiBase.EPILOG)

    def parse_args(self):
        args = self.argument_parser.parse_args()
        if args.env:
            self.env(args.env)
        self.debug(args.debug)
        self.accept("application/" + args.accept if args.accept else None)
        return args

    @abc.abstractmethod
    def info(self):
        return "ABSTRACT"
